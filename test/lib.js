/* generated by Buddy 3.0.0-beta-6 */

(function(root) {
	/**
	 * Load or retrieve cached version of requested module with id 'path' or 'path/index'
	 * @param {String} path
	 * @returns {Object}
	 */
	function require (path) {
		// Find in cache
		var m = require.modules[path] || require.modules[path + '/index'];

		if (!m) {
			// Handle versioned modules when called without version number
			var p, idx;
			for (var p in require.modules) {
				if ((idx = p.indexOf('#')) != -1) {
					if (path == p.slice(0, idx)) {
						m = require.modules[p];
						break;
					}
				}
			}
			if (!m) throw new Error("Couldn't find module for: " + path);
		}

		// Instantiate the module if it's export object is not yet defined
		if (!m.exports) {
			// Convert 'lazy' evaluated string to Function
			if ('string' == typeof m) {
				// 'm' is key to raw source
				m = require.modules[path] = new Function('require', 'module', 'exports', require.modules[m]);
			}
			m.exports = {};
			m.filename = path;
			m.call(null, require, m, m.exports);
		}

		// Return the exports object
		return m.exports;
	}

	// Cache of module objects
	require.modules = {};

	/**
	 * Retrieve raw 'lazy' module source
	 * @param {String} path
	 * @returns {String}
	 */
	require.raw = function requireRaw (path) {
		return require.modules['raw:' + path] || '';
	};

	/**
	 * Register a module with id of 'path' and callback of 'fn'
	 * Alternatively accepts 'fn' string for lazy evaluation
	 * @param {String} path
	 * @param {Function|String} fn [signature should be of type (require, module, exports)]
	 */
	require.register = function requireRegister (path, fn) {
		if ('string' == typeof fn) {
			// Store raw source
			var key = 'raw:' + path;
			require.modules[key] = fn;
			require.modules[path] = key;
		} else {
			require.modules[path] = fn;
		}
	};

	// Expose
	root.require = require;

})((typeof window !== 'undefined') ? window : global);
require.register('src/index.js', function(require, module, exports) {
    'use strict';
    
    var useNative = document.documentElement.classList != null;
    
    var RE_TRIM = /^\s+|\s+$/g;
    
    /**
     * Check if 'element' has class 'clas'
     * @param {Element} element
     * @param {String} clas
     * @return {Boolean}
     */
    exports.hasClass = function (element, clas) {
    	if (useNative) {
    		return element.classList.contains(clas);
    	} else {
    		var classes = element.className.replace(RE_TRIM, '').split(' ');
    
    		return contains(classes, clas);
    	}
    };
    
    /**
     * Check if 'element' has a class matching 'pattern'
     * @param {Element} element
     * @param {String} pattern
     * @return {String}
     */
    exports.matchClass = function (element, pattern) {
    	var classes = element.className.replace(RE_TRIM, '').split(' ');
    
    	var clas = undefined;
    
    	for (var i = 0, n = classes.length; i < n; i++) {
    		clas = classes[i];
    		if (clas.indexOf(pattern) !== -1) {
    			return clas;
    		}
    	}
    	return '';
    };
    
    /**
     * Add class 'clas' to 'element'
     * @param {Element} element
     * @param {String} clas
     */
    exports.addClass = function (element, clas) {
    	if (useNative) {
    		element.classList.add(clas);
    	} else {
    		element.className += ' ' + clas;
    	}
    };
    
    /**
     * Remove class 'clas' from 'element'
     * @param {Element} element
     * @param {String} clas
     */
    exports.removeClass = function (element, clas) {
    	if (clas) {
    		if (useNative) {
    			element.classList.remove(clas);
    		} else {
    			var classes = element.className.replace(RE_TRIM, '').split(' ');
    
    			var results = [];
    
    			for (var i = 0, n = classes.length; i < n; i++) {
    				if (classes[i] !== clas) results.push(classes[i]);
    			}
    			element.className = results.join(' ');
    		}
    	}
    };
    
    /**
     * Toggle class 'clas' on 'element'
     * @param {Element} element
     * @param {String} clas
     */
    exports.toggleClass = function (element, clas) {
    	if (exports.hasClass(element, clas)) {
    		exports.removeClass(element, clas);
    	} else {
    		exports.addClass(element, clas);
    	}
    };
    
    /**
     * Replace class 'clasOld' with 'clasNew' on 'element'
     * @param {Element} element
     * @param {String} clas
     */
    exports.replaceClass = function (element, clasOld, clasNew) {
    	if (clasOld) {
    		if (clasNew) {
    			element.className = element.className.replace(clasOld, clasNew);
    		} else {
    			exports.removeClass(element, clasOld);
    		}
    	} else if (clasNew) {
    		exports.addClass(element, clasNew);
    	}
    };
    
    /**
     * Add class 'clas' to 'element', and remove after 'duration' milliseconds
     * @param {Element} element
     * @param {String} clas
     * @param {Number} duration
     */
    exports.addTemporaryClass = function (element, clas, duration) {
    	exports.addClass(element, clas);
    	setTimeout(function () {
    		exports.removeClass(element, clas);
    	}, duration);
    };
    
    /**
     * Determine if 'arr' contains 'item'
     * @param {Array} arr
     * @param {Object|String|Number} item
     * @returns {Boolean}
     */
    function contains(arr, item) {
    	for (var i = 0, n = arr.length; i < n; i++) {
    		if (arr[i] === item) return true;
    	}
    	return false;
    }
});